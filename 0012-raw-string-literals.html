<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0012-raw-string-literals - JMESPath Enhancement Proposals</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><a href="0001-nested-expressions.html">0001-nested-expressions</a></li><li class="chapter-item expanded affix "><a href="0003-functions.html">0003-functions</a></li><li class="chapter-item expanded affix "><a href="0004-pipes.html">0004-pipes</a></li><li class="chapter-item expanded affix "><a href="0005-array-slices.html">0005-array-slices</a></li><li class="chapter-item expanded affix "><a href="0006-improved-identifiers.html">0006-improved-identifiers</a></li><li class="chapter-item expanded affix "><a href="0007-filter-expressions.html">0007-filter-expressions</a></li><li class="chapter-item expanded affix "><a href="0008-exptype.html">0008-exptype</a></li><li class="chapter-item expanded affix "><a href="0009-improved.filters.html">0009-improved.filters</a></li><li class="chapter-item expanded affix "><a href="0010-slice-projects.html">0010-slice-projects</a></li><li class="chapter-item expanded affix "><a href="0011-let-function.html">0011-let-function</a></li><li class="chapter-item expanded affix "><a href="0012-raw-string-literals.html" class="active">0012-raw-string-literals</a></li><li class="chapter-item expanded affix "><a href="0018-lexical-scope.html">0018-lexical-scope</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">JMESPath Enhancement Proposals</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="raw-string-literals"><a class="header" href="#raw-string-literals">Raw String Literals</a></h1>
<ul>
<li>JEP: 12</li>
<li>Author: Michael Downling</li>
<li>Created: 2015-04-09</li>
</ul>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>This JEP proposes the following modifications to JMESPath in order to improve
the usability of the language and ease the implementation of parsers:</p>
<ul>
<li>
<p>Addition of a <strong>raw string literal</strong> to JMESPath that will allow expressions
to contain raw strings that are not mutated by JSON escape sequences (e.g.,
“\n”, “\r”, “\u005C”).</p>
</li>
<li>
<p>Deprecation of  the current literal parsing behavior that allows for unquoted
JSON strings to be parsed as JSON strings, removing an ambiguity in the
JMESPath grammar and helping to ensure consistency among implementations.</p>
</li>
</ul>
<p>This proposal seeks to add the following syntax to JMESPath:</p>
<pre><code>'foobar'
'foo\'bar'
`bar` -&gt; Parse error/warning (implementation specific)
</code></pre>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Raw string literals are provided in <a href="https://en.wikipedia.org/wiki/String_literal#Raw_strings">various programming languages</a> in order to prevent
language specific interpretation (i.e., JSON parsing) and remove the need for
escaping, avoiding a common problem called <a href="https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome">leaning toothpick syndrome (LTS)</a>. Leaning toothpick
syndrome is an issue in which strings become unreadable due to excessive use of
escape characters in order to avoid delimiter collision (e.g., <code>\\\\\\\\\\\\</code>).</p>
<p>When evaluating a JMESPath expression, it is often necessary to utilize string
literals that are not extracted from the data being evaluated, but rather
statically part of the compiled JMESPath expression. String literals are useful
in many areas, but most notably when invoking functions or building up
multi-select lists and hashes.</p>
<p>The following expression returns the number of characters found in the string
<code>&quot;foo&quot;</code>. When parsing this expression, <code>`&quot;foo&quot;`</code> is parsed as a JSON value
which produces the string literal value of <code>foo</code>:</p>
<pre><code>`&quot;foo&quot;`
</code></pre>
<p>The following expression is functionally equivalent. Notice that the quotes are
elided from the JSON literal:</p>
<pre><code>`foo`
</code></pre>
<p>These string literals are parsed using a JSON parser according to
<a href="https://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>, which will expand unicode
escape sequences, newline characters, and several other escape sequences
documented in RFC 4627 section 2.5.</p>
<p>For example, the use of an escaped unicode value <code>\\u002B</code> is expanded into
<code>+</code> in the following JMESPath expression:</p>
<pre><code>`&quot;foo\u002B&quot;` -&gt; &quot;foo+&quot;
</code></pre>
<p>You can escape escape sequences in JSON literals to prevent an escape sequence
from being expanded:</p>
<pre><code>`&quot;foo\\u002B&quot;` -&gt; &quot;foo\u002B&quot;
`foo\\u002B` -&gt; &quot;foo\u002B&quot;
</code></pre>
<p>While this allows you to provide literal strings, it presents the following
problems:</p>
<ol>
<li>
<p>Incurs an additional JSON parsing penalty.</p>
</li>
<li>
<p>Requires the cognitive overhead of escaping escape characters if you
actually want the data to be represented as it was literally provided
(which can lead to LTS). If the data being escaped was meant to be used
along with another language that uses <code>\\</code> as an escape character, then the
number of backslash characters doubles.</p>
</li>
<li>
<p>Introduces an ambiguous rule to the JMESPath grammar that requires a prose
based specification to resolve the ambiguity in parser implementations.</p>
</li>
</ol>
<p>The relevant literal grammar rules are currently defined as follows:</p>
<pre><code>literal = &quot;`&quot; json-value &quot;`&quot;
literal =/ &quot;`&quot; 1*(unescaped-literal / escaped-literal) &quot;`&quot;
unescaped-literal = %x20-21 /       ; space !
                        %x23-5B /   ; # - [
                        %x5D-5F /   ; ] ^ _
                        %x61-7A     ; a-z
                        %x7C-10FFFF ; |}~ ...
escaped-literal   = escaped-char / (escape %x60)
json-value = false / null / true / json-object / json-array /
             json-number / json-quoted-string
false = %x66.61.6c.73.65   ; false
null  = %x6e.75.6c.6c      ; null
true  = %x74.72.75.65      ; true
json-quoted-string = %x22 1*(unescaped-literal / escaped-literal) %x22
begin-array     = ws %x5B ws  ; [ left square bracket
begin-object    = ws %x7B ws  ; { left curly bracket
end-array       = ws %x5D ws  ; ] right square bracket
end-object      = ws %x7D ws  ; } right curly bracket
name-separator  = ws %x3A ws  ; : colon
value-separator = ws %x2C ws  ; , comma
ws              = *(%x20 /              ; Space
                    %x09 /              ; Horizontal tab
                    %x0A /              ; Line feed or New line
                    %x0D                ; Carriage return
                   )
json-object = begin-object [ member *( value-separator member ) ] end-object
member = quoted-string name-separator json-value
json-array = begin-array [ json-value *( value-separator json-value ) ] end-array
json-number = [ minus ] int [ frac ] [ exp ]
decimal-point = %x2E       ; .
digit1-9 = %x31-39         ; 1-9
e = %x65 / %x45            ; e E
exp = e [ minus / plus ] 1*DIGIT
frac = decimal-point 1*DIGIT
int = zero / ( digit1-9 *DIGIT )
minus = %x2D               ; -
plus = %x2B                ; +
zero = %x30                ; 0
</code></pre>
<p>The <code>literal</code> rule is ambiguous because <code>unescaped-literal</code> includes
all of the same characters that <code>json-value</code> match, allowing any value
that is valid JSON to be matched on either <code>unescaped-literal</code> or
<code>json-value</code>.</p>
<h3 id="rationale"><a class="header" href="#rationale">Rationale</a></h3>
<p>When implementing parsers for JMESPath, one must provide special case parsing
when parsing JSON literals due to the allowance of elided quotes around JSON
string literals (e.g., <code>`foo`</code>). This specific aspect of JMESPath cannot be
described unambiguously in a context free grammar and could become a common
cause of errors when implementing JMESPath parsers.</p>
<p>Parsing JSON literals has other complications as well. Here are the steps
needed to currently parse a JSON literal value in JMESPath:</p>
<ol>
<li>
<p>When a <code>`</code> token is encountered, begin parsing a JSON literal.</p>
</li>
<li>
<p>Collect each character between the opening <code>`</code> and closing <code>`</code>
tokens, including any escaped <code>`</code> characters (i.e., <code>\` </code>) and store the
characters in a variable (let’s call it <code>$lexeme</code>).</p>
</li>
<li>
<p>Copy the contents of <code>$lexeme</code> to a temporary value in which all leading
and trailing whitespace is removed. Let’s call this <code>$temp</code> (this is
currently not documented but required in the
<a href="https://github.com/jmespath/jmespath.test/blob/c532a20e3bca635fb6ca248e5e955e1bd146a965/tests/syntax.json#L592-L606">JMESPath compliance tests</a>).</p>
</li>
<li>
<p>If <code>$temp</code> can be parsed as valid JSON, then use the parsed result as the
value for the literal token.</p>
</li>
<li>
<p>If <code>$temp</code> cannot be parsed as valid JSON, then wrap the contents of
<code>$lexeme</code> in double quotes and parse the wrapped value as a JSON string,
making the following expressions equivalent: <code>`foo`</code> == <code>`&quot;foo&quot;`</code>, and
<code>`[1, ]`</code> == <code>`&quot;[1, ]&quot;`</code>.</p>
</li>
</ol>
<p>It is reasonable to assume that the most common use case for a JSON literal in
a JMESPath expression is to provide a string value to a function argument or
to provide a literal string value to a value in a multi-select list or
multi-select hash. In order to make providing string values easier, it was
decided that JMESPath should allow the quotes around the string to be elided.</p>
<p>This proposal posits that allowing quotes to be elided when parsing JSON
literals should be deprecated in favor of adding a proper string literal rule
to JMESPath.</p>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<p>A raw string literal is value that begins and ends with a single quote, does
not interpret escape characters, and may contain escaped single quotes to
avoid delimiter collision.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>Here are several examples of valid raw string literals and how they are
parsed:</p>
<ul>
<li>A basic raw string literal, parsed as <code>foo bar</code>:</li>
</ul>
<pre><code>'foo bar'
</code></pre>
<ul>
<li>An escaped single quote, parsed as <code>foo'bar</code>:</li>
</ul>
<pre><code>'foo\'bar'
</code></pre>
<ul>
<li>A raw string literal that contains new lines:</li>
</ul>
<pre><code>'foo
bar
baz!'
</code></pre>
<p>The above expression would be parsed as a string that contains new lines:</p>
<pre><code>foo
baz
bar!
</code></pre>
<ul>
<li>A raw string literal that contains escape characters,
parsed as <code>foo\\nbar</code>:</li>
</ul>
<pre><code>foo\nbar
</code></pre>
<h3 id="abnf"><a class="header" href="#abnf">ABNF</a></h3>
<p>The following ABNF grammar rules will be added, and is allowed anywhere an
expression is allowed:</p>
<pre><code>raw-string        = &quot;'&quot; *raw-string-char &quot;'&quot;
; The first grouping matches any character other than &quot;\&quot;
raw-string-char   = (%x20-26 / %x28-5B / %x5D-10FFFF) / raw-string-escape
raw-string-escape = escape [&quot;'&quot;]
</code></pre>
<p>This rule allows any character inside of a raw string, including an escaped
single quote.</p>
<p>In addition to adding a <code>raw-string</code> rule, the <code>literal</code> rule in the ABNF
will be updated to become:</p>
<pre><code>literal = &quot;`&quot; json-value &quot;`&quot;
</code></pre>
<h2 id="impact"><a class="header" href="#impact">Impact</a></h2>
<p>The impact to existing users of JMESPath is that the use of a JSON literal
in which the quotes are elided SHOULD be converted to use the string-literal
rule of the grammar. Whether or not this conversion is absolutely necessary
will depend on the specific JMESPath implementation.</p>
<p>Implementations MAY choose to support the old syntax of allowing elided quotes
in JSON literal expressions. If an implementation chooses this approach, the
implementation SHOULD raise some kind of warning to the user to let them know
of the deprecation and possible incompatibility with other JMESPath
implementations.</p>
<p>In order to support this type of variance in JMESPath implementations, all of
the JSON literal compliance test cases that involve elided quotes MUST be
removed, and test cases regarding failing on invalid unquoted JSON values MUST
not be allowed in the compliance test unless placed in a JEP 12 specific
test suite, allowing implementations that support elided quotes in JSON
literals to filter out the JEP 12 specific test cases.</p>
<h2 id="alternative-approaches"><a class="header" href="#alternative-approaches">Alternative approaches</a></h2>
<p>There are several alternative approaches that could be taken.</p>
<h3 id="leave-as-is"><a class="header" href="#leave-as-is">Leave as-is</a></h3>
<p>This is a valid and reasonable suggestion. Leaving JMESPath as-is would avoid
a breaking change to the grammar and users could continue to use multiple
escape characters to avoid delimiter collision.</p>
<p>The goal of this proposal is not to add functionality to JMESPath, but rather
to make the language easier to use, easier to reason about, and easier to
implement. As it currently stands, the behavior of JSON parsing is ambiguous
and requires special casing when implementing a JMESPath parser. It also allows
for minor differences in implementations due to this ambiguity.</p>
<p>Take the following example:</p>
<pre><code>`[1`
</code></pre>
<p>One implementation may interpret this expression as a JSON string with the
string value of <code>&quot;[1&quot;</code>, while other implementations may raise a parse error
because the first character of the expression appears to be valid JSON.</p>
<p>By updating the grammar to require valid JSON in the JSON literal token, we can
remove this ambiguity completely, removing a potential source of inconsistency
from the various JMESPath implementations.</p>
<h3 id="disallow-single-quotes-in-a-raw-string"><a class="header" href="#disallow-single-quotes-in-a-raw-string">Disallow single quotes in a raw string</a></h3>
<p>This proposal states that single quotes in a raw string literal must be escaped
with a backslash. An alternative approach could be to not allow single quotes
in a raw string literal. While this would simplify the <code>raw-string</code> grammar
rule, it would severely limit the usability of the <code>raw-string</code> rule, forcing
users to use the <code>literal</code> rule.</p>
<h3 id="use-a-customizable-delimiter"><a class="header" href="#use-a-customizable-delimiter">Use a customizable delimiter</a></h3>
<p>Several languages allow for a custom delimiter to be placed around a raw
string. For example, Lua allows for a <a href="https://www.lua.org/manual/5.2/manual.html#3.1">long bracket</a> notation in which raw
strings are surrounded by <code>[[]]</code> with any number of balanced = characters
between the brackets:</p>
<pre><code>[==[foo=bar]==] -- parsed as &quot;foo=bar&quot;
</code></pre>
<p>This approach is very flexible and removes the need to escape any characters;
however, this can not be expressed in a regular grammar. A parser would need to
keep track of the number of opened delimiters and ensure that it is closed with
the appropriate number of matching characters.</p>
<p>The addition of a string literal as described in this JEP does not preclude a
later addition of a heredoc or delimited style string literal as provided by
languages like Lua, <a href="https://dlang.org/lex.html#DelimitedString">D</a>,
<a href="https://en.wikipedia.org/wiki/C%2B%2B11#New_string_literals">C++</a>, etc…</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="0011-let-function.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="0018-lexical-scope.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="0011-let-function.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="0018-lexical-scope.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
