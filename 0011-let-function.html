<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0011-let-function - JMESPath Enhancement Proposals</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><a href="0001-nested-expressions.html">0001-nested-expressions</a></li><li class="chapter-item expanded affix "><a href="0003-functions.html">0003-functions</a></li><li class="chapter-item expanded affix "><a href="0004-pipes.html">0004-pipes</a></li><li class="chapter-item expanded affix "><a href="0005-array-slices.html">0005-array-slices</a></li><li class="chapter-item expanded affix "><a href="0006-improved-identifiers.html">0006-improved-identifiers</a></li><li class="chapter-item expanded affix "><a href="0007-filter-expressions.html">0007-filter-expressions</a></li><li class="chapter-item expanded affix "><a href="0008-exptype.html">0008-exptype</a></li><li class="chapter-item expanded affix "><a href="0009-improved.filters.html">0009-improved.filters</a></li><li class="chapter-item expanded affix "><a href="0010-slice-projects.html">0010-slice-projects</a></li><li class="chapter-item expanded affix "><a href="0011-let-function.html" class="active">0011-let-function</a></li><li class="chapter-item expanded affix "><a href="0012-raw-string-literals.html">0012-raw-string-literals</a></li><li class="chapter-item expanded affix "><a href="0018-lexical-scope.html">0018-lexical-scope</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">JMESPath Enhancement Proposals</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lexical-scoping"><a class="header" href="#lexical-scoping">Lexical Scoping</a></h1>
<ul>
<li>JEP: 11</li>
<li>Author: James Saryerwinnie</li>
<li>Created: 2015-02-24</li>
</ul>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>This JEP proposes a new function <code>let()</code> (originally proposed by Michael
Dowling) that allows for evaluating an expression with an explicitly
defined lexical scope. This will require some changes to the lookup
semantics in JMESPath to introduce scoping, but provides useful
functionality such as being able to refer to elements defined outside of
the current scope used to evaluate an expression.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>As a JMESPath expression is being evaluated, the current element, which
can be explicitly referred to via the <code>@</code> token, changes as expressions
are evaluated. Given a simple sub expression such as <code>foo.bar</code>, first
the <code>foo</code> expression is evaluted with the starting input JSON document,
and the result of that expression is then used as the current element
when the <code>bar</code> element is evaluted. Conceptually we're taking some
object, and narrowing down its current element as the expression is
evaluted.</p>
<p>Once we've drilled down to a specific current element, there is no way,
in the context of the currently evaluated expression, to refer to any
elements outside of that element. One scenario where this is problematic
is being able to refer to a parent element.</p>
<p>For example, suppose we had this data:</p>
<pre><code>    {&quot;first_choice&quot;: &quot;WA&quot;,
     &quot;states&quot;: [
       {&quot;name&quot;: &quot;WA&quot;, &quot;cities&quot;: [&quot;Seattle&quot;, &quot;Bellevue&quot;, &quot;Olympia&quot;]},
       {&quot;name&quot;: &quot;CA&quot;, &quot;cities&quot;: [&quot;Los Angeles&quot;, &quot;San Francisco&quot;]},
       {&quot;name&quot;: &quot;NY&quot;, &quot;cities&quot;: [&quot;New York City&quot;, &quot;Albany&quot;]},
     ]
    }
</code></pre>
<p>Let's say we wanted to get the list of cities of the state
corresponding to our <code>first_choice</code> key. We'll make the assumption that
the state names are unique in the <code>states</code> list. This is currently not
possible with JMESPath. In this example we can hard code the state <code>WA</code>:</p>
<pre><code>    states[?name==`WA`].cities
</code></pre>
<p>but it is not possible to base this on a value of <code>first_choice</code>, which
comes from the parent element. This JEP proposes a solution that makes
this possible in JMESPath.</p>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<p>There are two components to this JEP, a new function, <code>let()</code>, and a
change to the way that identifiers are resolved.</p>
<h3 id="the-let-function"><a class="header" href="#the-let-function">The let() Function</a></h3>
<p>The <code>let()</code> function is heavily inspired from the <code>let</code> function
commonly seen in the Lisp family of languages:</p>
<ul>
<li><a href="https://clojuredocs.org/clojure.core/let">https://clojuredocs.org/clojure.core/let</a></li>
<li><a href="http://docs.racket-lang.org/guide/let.html">http://docs.racket-lang.org/guide/let.html</a></li>
</ul>
<p>The let function is defined as follows:</p>
<pre><code>    any let(object scope, expression-&gt;any expr)
</code></pre>
<p><code>let</code> is a function that takes two arguments. The first argument is a
JSON object. This hash defines the names and their corresponding values
that will be accessible to the expression specified in the second
argument. The second argument is an expression reference that will be
evaluated.</p>
<h3 id="resolving-identifiers"><a class="header" href="#resolving-identifiers">Resolving Identifiers</a></h3>
<p>Prior to this JEP, identifiers are resolved by consulting the current
context in which the expression is evaluted. For example, using the same
<code>search</code> function as defined in the JMESPath specification, the
evaluation of:</p>
<pre><code>    search(foo, {&quot;foo&quot;: &quot;a&quot;, &quot;bar&quot;: &quot;b&quot;}) -&gt; &quot;a&quot;
</code></pre>
<p>will result in the <code>foo</code> identifier being resolved in the context of the
input object <code>{&quot;foo&quot;: &quot;a&quot;, &quot;bar&quot;: &quot;b&quot;}</code>. The context object defines
<code>foo</code> as <code>a</code>, which results in the identifier <code>foo</code> being resolved as
<code>a</code>.</p>
<p>In the case of a sub expression, where the current evaluation context
changes once the left hand side of the sub expression is evaluted:</p>
<pre><code>    search(a.b, {&quot;a&quot;: {&quot;b&quot;: &quot;y&quot;}) -&gt; &quot;y&quot;
</code></pre>
<p>The identifier <code>b</code> is resolved with a current context of <code>{&quot;b&quot;: &quot;y&quot;}</code>,
which results in a value of <code>y</code>.</p>
<p>This JEP adds an additional step to resolving identifiers. In addition
to the implicit evaluation context that changes based on the result of
continually evaluating expressions, the <code>let()</code> command allows for
additional contexts to be specified, which we refer to by the common
name scope. The steps for resolving an identifier are:</p>
<ul>
<li>Attempt to lookup the identifier in the current evaluation context.</li>
<li>If this identifier is not resolved, look up the value in the current
scope provided by the user.</li>
<li>If the idenfitier is not resolved and there is a parent scope,
attempt to resolve the identifier in the parent scope. Continue
doing this until there is no parent scope, in which case, if the
identifier has not been resolved, the identifier is resolved as
<code>null</code>.</li>
</ul>
<p>Parent scopes are created by nested <code>let()</code> calls.</p>
<p>Below are a few examples to make this more clear. First, let's examine
the case where the identifier can be resolved from the current
evaluation context:</p>
<pre><code>    search(let({a: `x`}, &amp;b), {&quot;b&quot;: &quot;y&quot;}) -&gt; &quot;y&quot;
</code></pre>
<p>In this scenario, we are evaluating the expression <code>b</code>, with the context
object of <code>{&quot;b&quot;: &quot;y&quot;}</code>. Here <code>b</code> has a value of <code>y</code>, so the result of
this function is <code>y</code>.</p>
<p>Now let's look at an example where an identifier is resolved from a
scope object provided via <code>let()</code>:</p>
<pre><code>    search(let({a: `x`}, &amp;a, {&quot;b&quot;: &quot;y&quot;})) -&gt; &quot;x&quot;
</code></pre>
<p>Here, we're trying to resolve the <code>a</code> identifier. The current
evaluation context, <code>{&quot;b&quot;: &quot;y&quot;}</code>, does not define <code>a</code>. Normally, this
would result in the identifier being resolved as <code>null</code>:</p>
<pre><code>    search(a, {&quot;b&quot;: &quot;y&quot;}) -&gt; null
</code></pre>
<p>However, we now fall back to looking in the provided scope object
<code>{&quot;a&quot;: &quot;x&quot;}</code>, which was provided as the first argument to <code>let</code>. Note
here that the value of <code>a</code> has a value of <code>&quot;x&quot;</code>, so the identifier is
resolved as <code>&quot;x&quot;</code>, and the return value of the <code>let()</code> function is
<code>&quot;x&quot;</code>.</p>
<p>Finally, let's look at an example of parent scopes. Consider the
following expression:</p>
<pre><code>    search(let({a: `x`}, &amp;let({b: `y`}, &amp;{a: a, b: b, c: c})),
           {&quot;c&quot;: &quot;z&quot;}) -&gt; {&quot;a&quot;: &quot;x&quot;, &quot;b&quot;: &quot;y&quot;, &quot;c&quot;: &quot;z&quot;}
</code></pre>
<p>Here we have nested let calls, and the expression we are trying to
evaluate is the multiselect hash <code>{a: a, b: b, c: c}</code>. The <code>c</code>
identifier comes from the evaluation context <code>{&quot;c&quot;: &quot;z&quot;}</code>. The <code>b</code>
identifier comes from the scope object in the second <code>let</code> call:
<code>{b: `y`}</code>. And finally, here's the lookup process for the <code>a</code>
identifier:</p>
<ul>
<li>Is <code>a</code> defined in the current evaluation context? No.</li>
<li>Is <code>a</code> defined in the scope provided by the user? No.</li>
<li>Is there a parent scope? Yes</li>
<li>Does the parent scope, <code>{a: `x`}</code>, define <code>a</code>? Yes, <code>a</code> has the
value of <code>&quot;x&quot;</code>, so <code>a</code> is resolved as the string <code>&quot;x&quot;</code>.</li>
</ul>
<h3 id="current-node-evaluation"><a class="header" href="#current-node-evaluation">Current Node Evaluation</a></h3>
<p>While the JMESPath specification defines how the current node is
determined, it is worth explicitly calling out how this works with the
<code>let()</code> function and expression references. Consider the following
expression:</p>
<pre><code>    a.let({x: `x`}, &amp;b.let({y: `y`}, &amp;c))
</code></pre>
<p>Given the input data:</p>
<pre><code>    {&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: &quot;foo&quot;}}}
</code></pre>
<p>When the expression <code>c</code> is evaluated, the current evaluation context is
<code>{&quot;c&quot;: &quot;foo&quot;}</code>. This is because this expression isn't evaluated until
the second <code>let()</code> call evaluates the expression, which does not occur
until the first <code>let()</code> function evaluates the expression.</p>
<h3 id="motivating-example"><a class="header" href="#motivating-example">Motivating Example</a></h3>
<p>With these changes defined, the expression in the &quot;Motivation&quot; section
can be be written as:</p>
<pre><code>    let({first_choice: first_choice}, &amp;states[?name==first_choice].cities)
</code></pre>
<p>Which evalutes to <code>[&quot;Seattle&quot;, &quot;Bellevue&quot;, &quot;Olympia&quot;]</code>.</p>
<h2 id="rationale"><a class="header" href="#rationale">Rationale</a></h2>
<p>If we just consider the feature of being able to refer to a parent
element, this approach is not the only way to accomplish this. We could
also allow for explicit references using a specific token, say <code>$</code>. The
original example in the &quot;Motivation&quot; section would be:</p>
<pre><code>    states[?name==$.first_choice].cities
</code></pre>
<p>While this could work, this has a number of downsides, the biggest one
being that you'll need to always keep track of the parent element. You
don't know ahead of time if you're going to need the parent element,
so you'll always need to track this value. It also doesn't handle
nested lexical scopes. What if you wanted to access a value in the grand
parent element? Requiring an explicit binding approach via <code>let()</code>
handles both these cases, and doesn't require having to track parent
elements. You only need to track additional scope when <code>let()</code> is used.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="0010-slice-projects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="0012-raw-string-literals.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="0010-slice-projects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="0012-raw-string-literals.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
